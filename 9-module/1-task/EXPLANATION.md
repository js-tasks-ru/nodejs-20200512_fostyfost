# Чат

[Websockets](https://learn.javascript.ru/websockets)
[Socket.io](https://socket.io)

## Чат с использованием Websockets

Механизмы аутентификации для Websocket можно разделить на 2 основных вида:

1. Аутентификация на основании данных, передаваемых при установке соединения по HTTP.
1. Разрешение подключения всем клиентам с заданным таймаутом для передачи ими аутентификационных данных. 
Например: мы разрешаем подключение всем пользователям, но при первоначальном соединении помечаем такого клиента 
как непроверенного, не имеющего возможности ни получать, ни отправлять никакие сообщения. 
Таким клиентам даётся некоторое время, скажем, 5 секунд, для того, чтобы отправить 
свои аутентификационные данные (токен, логин/пароль, что-то другое). Если данные неверны или вовсе не были 
отправлены – сервер принудительно завершает такое соединение.

Ввиду простоты реализации мы с вами остановимся именно на первом подходе, 
который не требует никаких специальных условий для своей работы и отлично поддерживается всеми клиентами.

Для того, чтобы «вклиниться» в процесс подключения клиента и добавить логику аутентификации 
в библиотеке `socket.io` есть функция `io.use((socket, next) => {});`. Эта функция с одной стороны даёт нам доступ 
к оригинальному http запросу (его данные можно получить с помощью `socket.handshake`), 
с другой стороны возможность асинхронно выполнить любые проверки и вызвать функцию `done`, 
в которую можно передать объект ошибки (и прекратить попытку подключения), 
либо вызвать её без аргументов и позволить клиенту подключиться.

Логика аутентификации может выглядеть следующим образом:

```js

io.use(async function(socket, next) {
  const token = socket.handshake.query.token;

  if (!token) return next(new Error('anonymous sessions are not allowed'));

  const session = await Session.findOne({token}).populate('user');

  if (!session) return next(new Error('wrong or expired session token'));

  socket.user = session.user;

  next();
});

```

Вначале мы проверяем наличие параметра запроса `token`, а затем выполняем необходимые проверки на основе 
значения этого токена, т.е. поиск сессии в базе данных. Если всё хорошо – сохраняем найденного пользователя 
в объекте `socket` для последующей обработки.

## Обработка пользовательских сообщений

Для сохранения сообщение в базе данных используем следующие значения:

* `user` – имя пользователя, которое мы можем получить из `socket.user.displayName`,
* `chat` – идентификатор пользователя – `socket.user.id`,
* `text` – собственно текст сообщения,
* `date` – текущая дата.

Таким образом у нас получится подобный код:

```js

io.on('connection', function(socket) {
  socket.on('message', async (msg) => {
    const date = new Date();

    await Message.create({
      chat: socket.user.id,
      user: socket.user.displayName,
      text: msg,
      date: date,
    });
  });
});

```

## `GET /messages`

Поиск сообщений выполняется с помощью операции `.find`, так как нас интересуют сообщения именно текущего пользователя, 
мы должны передать в параметры поиска ключ `chat`, равный идентификатору текущего пользователя. 
Кроме этого есть еще некоторые моменты, которые стоит учесть. А именно:

1. Сортировка. Мы с вами хотим получить сообщения в обратном хронологическом порядке, то есть сначала самые новые. 
Для этого после вызова `.find()` добавим вызов `.sort({ date: 1 })`.
1. Количество элементов. Обычно мессенджеры при старте не загружают всю историю чата, это было бы слишком долго, 
а ограничиваются некоторым количеством сообщением. При желании пользователь может дозагрузить 
предыдущие сообщения позже. Для того, чтобы получить из базы лишь 20 сообщений, добавим вызов `.limit(20)`.

В итоге запрос к базе данных будет выглядеть следующим образом:

```js

const messages = await Message.find({chat: ctx.user.id}).sort({ date: 1 }).limit(20);

```

Теперь необходимо выполнить мапинг документов в объекты, требующиеся клиенту. 
Как и раньше вынесем функцию в отдельный модуль `mappers/message`:

```js

module.exports = function mapMessage(message) {
  return {
    id: message.id,
    text: message.text,
    user: message.user,
    date: message.date,
  };
};

```

А затем используем эту функцию в контроллере `controllers/message`:

```js

const Message = require('../models/Message');
const mapMessage = require('../mappers/message');

module.exports.messageList = async function messages(ctx, next) {
  const messages = await Message.find({chat: ctx.user.id}).sort({date: 1}).limit(20);

  ctx.body = {
    messages: messages.map(mapMessage),
  };
};

```
